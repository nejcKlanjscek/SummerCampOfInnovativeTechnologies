//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES
#include <SI_EFM8UB1_Register_Enums.h>
#include "VCPXpress.h"
#include "descriptor.h"
#include "led_driver.h"
#include <stdio.h>
#include <string.h>
#define PACKET_SIZE 64
uint8_t xdata TX_Packet[PACKET_SIZE] = "1,2,3,4\n";
uint16_t xdata OutCount;
int mode=1;
int debounce=0, mode_show_delay=90;
#define PACKET_SIZE 64

//-----------------------------------------------------------------------------
// TIMER2_ISR
//-----------------------------------------------------------------------------
//
// TIMER2 ISR Content goes here. Remember to clear flag bits:
// TMR2CN0::TF2H (Timer # High Byte Overflow Flag)
// TMR2CN0::TF2L (Timer # Low Byte Overflow Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (TIMER2_ISR, TIMER2_IRQn)
  {

    TMR2CN0_TF2H = 0;
    TMR2CN0_TF2L = 0;
    if (debounce) debounce--; // how long we need to wait for debounce event
    if (mode_show_delay) mode_show_delay--; //how long mode indicator shoud be lit before we move to bargraph
  }

//-----------------------------------------------------------------------------
// ADC0EOC_ISR
//-----------------------------------------------------------------------------
//
// ADC0EOC ISR Content goes here. Remember to clear flag bits:
// ADC0CN0::ADINT (Conversion Complete Interrupt Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (ADC0EOC_ISR, ADC0EOC_IRQn)
  {
    unsigned int ad_result=ADC0;
    unsigned int buf_len=0;
    ADC0CN0_ADINT=0;
    if (mode==2){
          ad_result=(ad_result-440)*4;
      }
      if (mode==1){
          ad_result=(ad_result-50)*4; //(ad_result-312)*4;
      }
      if(mode==4){
          ad_result-=3;
      //    if (ad_result>1024) ad_result=0;
      }
    //led_meter(ad_result);
    //running_leds();
      if (ad_result>30000) ad_result=0;
      //ad_result=ad_result&0x3FF;
    if(mode_show_delay) function_indicator(mode);
    else {
        if(mode==4){
            log_led_meter(ad_result);
        }
        else{
            led_meter(ad_result);
        }
    }

    sprintf(TX_Packet,"%u\n", ad_result);
    buf_len=strlen(TX_Packet);
    Block_Write (TX_Packet, buf_len, &OutCount);

  }

//-----------------------------------------------------------------------------
// INT0_ISR
//-----------------------------------------------------------------------------
//
// INT0 ISR Content goes here. Remember to clear flag bits:
// TCON::IE0 (External Interrupt 0)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (INT0_ISR, INT0_IRQn)
  {
  TCON_IE0=0;
  if(debounce==0){
      mode++;
      debounce=2;
      mode_show_delay=15;
  }
  if(mode==5) mode=1;

  switch(mode){
    case 1:
      ADC0MX = ADC0MX_ADC0MX__ADC0P1;
      break;
    case 2:
      ADC0MX = ADC0MX_ADC0MX__ADC0P2;
      break;
    case 3:
      ADC0MX = ADC0MX_ADC0MX__ADC0P4;
      break;
    default:
      ADC0MX = ADC0MX_ADC0MX__ADC0P3;
  }
  }

